(define type-tower '(integer rational real complex))

(define (raise value to-type)
  (define (set-tag type value) (cons type value))
  (define (get-tag x) (car x))
  (define (get-value x) (cdr x))
  (define coercions
    (list (cons (cons 'integer 'rational)
		(lambda (x) (set-tag 'rational (cons (get-value x) 1.0))))
	  (cons (cons 'rational 'real)
		(lambda (x)
		  (let ((dividend (car (get-value x)))
			(divisor (cdr (get-value x))))
		    (set-tag 'real (/ dividend divisor)))))
	  (cons (cons 'real 'complex)
		(lambda (x) (set-tag 'complex (cons (get-value x) 0))))))
  (define (raise-next value coercions)
    (cond ((eq? (get-tag value) to-type) value)
	  ((null? coercions) (error "no coercion found"))
	  (else
	   (let ((current-type (get-tag value)))
	     (let ((next-coercion (car coercions))
		   (remaining-coercions (cdr coercions)))
	       (if (eq? current-type (caar next-coercion))
		   (let ((new-value ((cdr next-coercion) value)))
		     (raise-next new-value remaining-coercions))
		   (raise-next value remaining-coercions)))))))
  (raise-next value coercions))

(define a (cons 'integer 3))
;; (raise a 'rational)
;; (rational 3 . 1.)
;; (raise a 'real)
;; (real . 3.)
;; (raise a 'complex)
;; (complex 3. . 0)

(define b (cons 'rational (cons 3 2)))
;; (raise b 'real)
;; (real . 3/2)
;; (raise b 'complex)
;; (complex 3/2 . 0)

(define c (cons 'real 1.53))
;; (raise c 'complex)
;; (complex 1.53 . 0)
